from BioInfoToolkit.HMM import viterbi_learning
import numpy.typing as npt
import os
from BioInfoToolkit.IO.IO import readTextFile, result_path_from_input_path, solution_path_from_input_path, writeTextFile
from BioInfoToolkit.IO.IO_utils import emission_matrix_from_dict, matrix_text_to_dict, print_and_save_matrix,trans_matrix_from_dict
from testing import float_matrices_match

"""
https://rosalind.info/problems/ba10i/

Viterbi learning

    Given: A sequence of emitted symbols x = x1 ... xn in an alphabet A, generated by a k-state HMM with unknown transition and emission probabilities, initial Transition and Emission matrices and a number of iterations i.

    Return: A matrix of transition probabilities Transition and a matrix of emission probabilities Emission that maximizes Pr(x, π) over all possible transition and emission matrices and over all hidden paths π. 
"""

OutputT = tuple[list[list[float]], list[list[float]]]


def verify(result: OutputT, solution: OutputT) -> bool:
    trans_matrix_res, emission_matrix_res = result
    trans_matrix_sol, emission_matrix_sol = solution
    tm = float_matrices_match(trans_matrix_res, trans_matrix_sol)
    em = float_matrices_match(emission_matrix_res, emission_matrix_sol)
    correct = tm and em
    return correct


def solve(state_space: list[str], obs_space: list[str], observations: str, trans_matrix: npt.NDArray, emission_matrix: npt.NDArray, n_iters: int) -> OutputT:
    trans_matrix2, emission_matrix2 = viterbi_learning(state_space, obs_space, observations,
                                                     trans_matrix, emission_matrix, n_iters)

    trans_matrix_: list[list[float]] = trans_matrix2.tolist()
    emission_matrix_: list[list[float]] = emission_matrix2.tolist()

    return trans_matrix_, emission_matrix_


def load_results(path: str) -> OutputT:
    lines = readTextFile(path)
    state_space = lines[0].split()
    n = len(state_space)

    trans_matrix: list[list[float]] = []
    for line in lines[1:1+n]:
        vals = line.split()
        vals = [float(v) for v in vals[1:]]
        trans_matrix.append(vals)

    emission_matrix: list[list[float]] = []
    for line in lines[1+n+2:1+n+2+n]:
        vals = line.split()
        vals = [float(v) for v in vals[1:]]
        emission_matrix.append(vals)

    return trans_matrix, emission_matrix


def solve_and_check(input_path: str) -> bool:
    lines = readTextFile(input_path)
    lines = [line for line in lines if len(line) and not line.isspace()]

    iters = int(lines[0])
    observations = lines[2]
    obs_space = lines[4].split()
    state_space = lines[6].split()

    K = len(state_space)
    T = len(obs_space)

    trans_matrix_header = lines[8].split()
    trans_matrix_lines = [line.split() for line in lines[9:9+K]]

    idx = 9+K+1
    emission_matrix_header = lines[idx].split()
    emission_matrix_lines = [line.split() for line in lines[idx+1:idx+1+T]]

    trans_dict = matrix_text_to_dict(trans_matrix_header, trans_matrix_lines)
    trans_matrix = trans_matrix_from_dict(trans_dict, state_space)

    emission_dict = matrix_text_to_dict(
        emission_matrix_header, emission_matrix_lines)
    emission_matrix = emission_matrix_from_dict(
        emission_dict, state_space, obs_space)

    result = solve(
        state_space, obs_space, observations, trans_matrix, emission_matrix, iters)

    solution_path = solution_path_from_input_path(input_path)

    solution = load_results(solution_path)

    correct = verify(result, solution)
    return correct


if __name__ == "__main__":
    cwd = os.path.realpath(os.path.dirname(__file__))
    path = f'{cwd}/rosalind_ba10i_1.txt'

    lines = readTextFile(path)
    lines = [line for line in lines if len(line) and not line.isspace()]

    iters = int(lines[0])
    observations = lines[2]
    obs_space = lines[4].split()
    state_space = lines[6].split()

    K = len(state_space)
    T = len(obs_space)

    trans_matrix_header = lines[8].split()
    trans_matrix_lines = [line.split() for line in lines[9:9+K]]

    idx = 9+K+1
    emission_matrix_header = lines[idx].split()
    emission_matrix_lines = [line.split() for line in lines[idx+1:idx+1+T]]

    trans_dict = matrix_text_to_dict(trans_matrix_header, trans_matrix_lines)
    trans_matrix = trans_matrix_from_dict(trans_dict, state_space)

    emission_dict = matrix_text_to_dict(
        emission_matrix_header, emission_matrix_lines)
    emission_matrix = emission_matrix_from_dict(
        emission_dict, state_space, obs_space)
    
    trans_matrix, emission_matrix = solve(state_space, obs_space, observations, trans_matrix, emission_matrix, iters)

    result_path = result_path_from_input_path(path)
    writeTextFile(result_path, None, 'w')
    spacing = '\t'

    print_and_save_matrix(state_space, state_space,
                          trans_matrix, result_path, precision=4)

    print('-'*8)
    writeTextFile(result_path, '-'*8, 'a')

    print_and_save_matrix(obs_space, state_space,
                          emission_matrix, result_path, precision=4)

    correct = solve_and_check(path)
    print(correct)
